<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Completely Filled Rows Feature</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #1a1a2e;
            color: white;
        }
        .test-container {
            max-width: 800px;
            margin: 0 auto;
        }
        .test-result {
            background-color: #2a2a4e;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .success { border-left: 5px solid #4ECDC4; }
        .error { border-left: 5px solid #FF6B6B; }
        .warning { border-left: 5px solid #FECA57; }
        pre {
            background-color: #0f0f1e;
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
        }
        .bubble-row {
            display: flex;
            gap: 2px;
            margin: 5px 0;
            font-family: monospace;
        }
        .bubble {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üß™ Test: Completely Filled Descending Rows</h1>
        <p>This test verifies that new rows descending from the infinite stack are always completely filled with bubbles.</p>
        
        <div id="testResults"></div>
        
        <h2>üìä Test Results</h2>
        <div id="summary"></div>
        
        <h2>üîç Visual Row Representation</h2>
        <div id="visualRows"></div>
    </div>

    <script>
        // Mock the bubble colors
        const BUBBLE_COLORS = ['#FF6B6B', '#4ECDC4', '#1E3A8A', '#00FF88', '#FECA57', '#FF9FF3'];
        
        // Test class to simulate infinite stack generation
        class InfiniteStackTester {
            constructor() {
                this.difficulty = 'novice';
                this.difficultySettings = {
                    novice: { rowsToStart: 2, colors: 3, addRowFrequency: 8, timeBasedDescent: 15000 },
                    easy: { rowsToStart: 2, colors: 4, addRowFrequency: 6, timeBasedDescent: 12000 },
                    medium: { rowsToStart: 3, colors: 5, addRowFrequency: 5, timeBasedDescent: 10000 }
                };
                this.infiniteStack = [];
                this.canvas = { width: 400 };
                this.BUBBLE_RADIUS = 20;
                this.GRID_COL_SPACING = 40;
                this.GRID_COLS = 14;
            }
            
            generateInfiniteStack() {
                console.log('Generating infinite stack...');
                
                const settings = this.difficultySettings[this.difficulty];
                const colorSubset = BUBBLE_COLORS.slice(0, settings.colors);
                const maxBubblesPerRow = Math.floor((this.canvas.width - this.BUBBLE_RADIUS * 2) / this.GRID_COL_SPACING);
                const effectiveGridCols = Math.min(this.GRID_COLS, maxBubblesPerRow);
                
                // Generate 10 test rows
                for (let stackRow = 0; stackRow < 10; stackRow++) {
                    const rowData = new Array(effectiveGridCols).fill(null);
                    
                    // CRITICAL: Always fill ALL valid columns for new descending rows
                    for (let col = 0; col < effectiveGridCols; col++) {
                        let color;
                        
                        // Smart color generation algorithm for strategic gameplay
                        if (col > 0 && rowData[col-1] && Math.random() < 0.4) {
                            // 40% chance to match previous column for horizontal clusters
                            color = rowData[col-1];
                        } else if (stackRow > 0 && this.infiniteStack[stackRow-1] && 
                                  this.infiniteStack[stackRow-1][col] && Math.random() < 0.3) {
                            // 30% chance to match above bubble for vertical clusters
                            color = this.infiniteStack[stackRow-1][col];
                        } else {
                            // Random color from available subset
                            color = colorSubset[Math.floor(Math.random() * colorSubset.length)];
                        }
                        
                        // GUARANTEE: Every position gets a bubble (no null values)
                        rowData[col] = color;
                    }
                    
                    this.infiniteStack.push(rowData);
                }
                
                console.log('Generated infinite stack with', this.infiniteStack.length, 'completely filled rows');
                return this.infiniteStack;
            }
            
            testNewRowGeneration() {
                if (this.infiniteStack.length === 0) {
                    this.generateInfiniteStack();
                }
                
                const newRowData = this.infiniteStack.shift();
                const settings = this.difficultySettings[this.difficulty];
                const colorSubset = BUBBLE_COLORS.slice(0, settings.colors);
                const maxBubblesPerRow = Math.floor((this.canvas.width - this.BUBBLE_RADIUS * 2) / this.GRID_COL_SPACING);
                const effectiveGridCols = Math.min(this.GRID_COLS, maxBubblesPerRow);
                
                // Simulate the addNewRow logic
                const finalRow = [];
                for (let col = 0; col < effectiveGridCols; col++) {
                    let color = newRowData[col];
                    
                    // Fallback if infinite stack doesn't have a color
                    if (!color) {
                        color = colorSubset[Math.floor(Math.random() * colorSubset.length)];
                        console.warn(`Missing color at col ${col}, using fallback: ${color}`);
                    }
                    
                    finalRow.push(color);
                }
                
                return {
                    originalRow: newRowData,
                    finalRow: finalRow,
                    totalColumns: effectiveGridCols,
                    bubblesPlaced: finalRow.length,
                    completelyFilled: finalRow.length === effectiveGridCols && finalRow.every(color => color !== null)
                };
            }
        }
        
        // Run the tests
        function runTests() {
            const resultsDiv = document.getElementById('testResults');
            const summaryDiv = document.getElementById('summary');
            const visualDiv = document.getElementById('visualRows');
            
            const tester = new InfiniteStackTester();
            let testsPassed = 0;
            let totalTests = 0;
            let allRowsCompletelyFilled = true;
            const testResults = [];
            
            // Test 1: Generate infinite stack
            try {
                tester.generateInfiniteStack();
                resultsDiv.innerHTML += `<div class="test-result success">‚úÖ Test 1: Infinite stack generation - PASSED</div>`;
                testsPassed++;
            } catch (error) {
                resultsDiv.innerHTML += `<div class="test-result error">‚ùå Test 1: Infinite stack generation - FAILED: ${error.message}</div>`;
                allRowsCompletelyFilled = false;
            }
            totalTests++;
            
            // Test 2-6: Generate multiple new rows
            for (let i = 1; i <= 5; i++) {
                try {
                    const result = tester.testNewRowGeneration();
                    testResults.push(result);
                    
                    if (result.completelyFilled) {
                        resultsDiv.innerHTML += `<div class="test-result success">‚úÖ Test ${i+1}: New row ${i} completely filled (${result.bubblesPlaced}/${result.totalColumns}) - PASSED</div>`;
                        testsPassed++;
                    } else {
                        resultsDiv.innerHTML += `<div class="test-result error">‚ùå Test ${i+1}: New row ${i} NOT completely filled (${result.bubblesPlaced}/${result.totalColumns}) - FAILED</div>`;
                        allRowsCompletelyFilled = false;
                    }
                } catch (error) {
                    resultsDiv.innerHTML += `<div class="test-result error">‚ùå Test ${i+1}: New row ${i} generation - FAILED: ${error.message}</div>`;
                    allRowsCompletelyFilled = false;
                }
                totalTests++;
            }
            
            // Display summary
            const successRate = Math.round((testsPassed / totalTests) * 100);
            summaryDiv.innerHTML = `
                <div class="test-result ${successRate === 100 ? 'success' : 'warning'}">
                    <h3>üìä Test Summary</h3>
                    <p><strong>Tests Passed:</strong> ${testsPassed}/${totalTests} (${successRate}%)</p>
                    <p><strong>All Rows Completely Filled:</strong> ${allRowsCompletelyFilled ? '‚úÖ YES' : '‚ùå NO'}</p>
                    <p><strong>Feature Status:</strong> ${allRowsCompletelyFilled ? '‚úÖ WORKING CORRECTLY' : '‚ùå NEEDS FIXING'}</p>
                </div>
            `;
            
            // Visual representation
            let visualHtml = '<h3>Generated Row Examples:</h3>';
            testResults.forEach((result, index) => {
                visualHtml += `<div style="margin: 10px 0;"><strong>Row ${index + 1}:</strong></div>`;
                visualHtml += '<div class="bubble-row">';
                result.finalRow.forEach(color => {
                    visualHtml += `<div class="bubble" style="background-color: ${color}">‚óè</div>`;
                });
                visualHtml += '</div>';
                visualHtml += `<small>Status: ${result.completelyFilled ? '‚úÖ Complete' : '‚ùå Incomplete'} (${result.bubblesPlaced}/${result.totalColumns} bubbles)</small><br><br>`;
            });
            
            visualDiv.innerHTML = visualHtml;
            
            // Log to console as well
            console.log('=== COMPLETELY FILLED ROWS TEST RESULTS ===');
            console.log(`Tests Passed: ${testsPassed}/${totalTests}`);
            console.log(`All Rows Completely Filled: ${allRowsCompletelyFilled}`);
            console.log('Test Results:', testResults);
        }
        
        // Run tests when page loads
        document.addEventListener('DOMContentLoaded', runTests);
    </script>
</body>
</html>
